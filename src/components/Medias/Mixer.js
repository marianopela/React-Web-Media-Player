import React, { Component } from 'react';
import { connect } from 'react-redux';
import Video from "./Channels/Video";
import Audio from "./Channels/Audio";
import Slideshow from "./Channels/Slideshow";
import Vinyl from "./Channels/Vinyl"
import { isIE, isNaN } from '../../services/Utils';

const MAX_DIFFERENCE_AUDIO_SLIDESHOW = 0.1; //in seconds
const BUFFER_UPDATE_PRECISION = 0.1; //in seconds
const IE_IMPRECISION = 1
const ASKED_TIME_TREATED = "isTreated";
const FLOAT_IMPRECISION = 0.1;

class Mixer extends Component {

    synchronize = () => {
        if (!this.props.channelsWait) {
            if (this.props.hasVideo) {
                let currentTime = this.video.getCurrentTime();
                if (currentTime <= this.video.getDuration() + IE_IMPRECISION) {
                    this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: currentTime } });
                } else {
                    return;
                }
            } else {
                if (this.props.hasAudio && this.props.hasSlideshow) {
                    if (this.audio.getDuration() > this.props.currentTime) {
                        let currentTime = this.audio.getCurrentTime();
                        if (currentTime <= this.audio.getDuration() + IE_IMPRECISION) {
                            this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: currentTime } });
                            let diff = Math.abs(this.audio.getCurrentTime() - this.slideshow.getCurrentTime());
                            if (diff > MAX_DIFFERENCE_AUDIO_SLIDESHOW)//re-synchronize audio and slideshow 
                                this.slideshow.changeTime(this.audio.getCurrentTime());
                        } else {
                            return;
                        }
                    } else {
                        this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: this.slideshow.getCurrentTime() } });
                    }
                } else if (this.props.hasAudio && this.props.hasVinyl) {
                    let currentTime = this.audio.getCurrentTime();
                    if (currentTime <= this.audio.getDuration()) {
                        this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: currentTime } });
                    } else {
                        return;
                    }
                } else {
                    this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: this.slideshow.getCurrentTime() } });
                }
            }
        }
        //Sometime the video is already loaded and no event generated by the HTML5 API allows you to turn off the loading state, this force it 
        //May generate undesired side-effects
        if (this.props.hasVideo && this.props.currentTime > 0.1) {
            this.props.dispatch({ type: 'NOT_LOADING' });
        }

        if (this.props.currentTime >= this.props.duration && this.props.duration > 0) {
            this.stop();
            this.props.dispatch({ type: 'READING_TERMINATED' });
            this.props.dispatch({ type: 'PAUSE' });
            this.props.dispatch({ type: 'SHOW_MENUS' });
            return;
        }
        this.refreshBufferState();
    };

    refreshBufferState = () => {
        let timeRangeBuffered;
        if (this.props.hasVideo) {
            timeRangeBuffered = this.video.timeRangeBuffered(this.props.currentTime);
        } else {
            if (this.props.hasAudio && this.props.hasSlideshow) {
                let audioTimeRangeBuffered = this.audio.timeRangeBuffered(this.props.currentTime);
                let slideshowTimeRangeBuffered = this.slideshow.timeRangeBuffered(this.props.currentTime);
                if (this.audio.getDuration() < this.props.currentTime || audioTimeRangeBuffered > this.audio.getDuration() - 0.1) {
                    timeRangeBuffered = this.slideshow.timeRangeBuffered(this.props.currentTime);
                } else {
                    timeRangeBuffered = (audioTimeRangeBuffered < slideshowTimeRangeBuffered) ? audioTimeRangeBuffered : slideshowTimeRangeBuffered;
                }
            } else if (this.props.hasAudio && this.props.hasVinyl) {
                timeRangeBuffered = this.audio.timeRangeBuffered(this.props.currentTime);
            } else {
                timeRangeBuffered = this.slideshow.timeRangeBuffered(this.props.currentTime);
            }
        }
        if (timeRangeBuffered !== this.props.timeRangeBuffered && Math.abs(timeRangeBuffered - this.props.timeRangeBuffered) >= BUFFER_UPDATE_PRECISION) {
            this.props.dispatch({ type: 'UPDATE_TIME_RANGE_BUFFERED', payload: { timeRangeBuffered: timeRangeBuffered } });
        }
    };

    play = () => {
        if (this.props.currentTime >= this.props.duration && this.props.duration > 0) {
            this.stop();
            this.props.dispatch({ type: 'NOT_LOADING' });
            this.props.dispatch({ type: 'PREVENT_MENU_HIDING' });
            this.props.dispatch({ type: 'PAUSE' });
            this.props.dispatch({ type: 'READING_TERMINATED' });
            this.props.dispatch({ type: 'SHOW_MENUS' });
            return;
        }
        window.clearInterval(this.bufferTimer);
        this.refreshBufferState();
        this.bufferTimer = window.setInterval(this.refreshBufferState);

        window.clearInterval(this.timer);
        this.synchronize();
        this.timer = window.setInterval(this.synchronize, 20);

        if (this.props.hasVideo) {
            this.video.play();
        }
        if (this.props.hasAudio) {
            //When the slideshow last longer than the audio track, it prevent to play the audio track when the current time is bigger than the audio duration 
            if (this.props.hasSlideshow) {
                if (this.props.currentTime < this.audio.getDuration()) this.audio.play();

            } else {
                this.audio.play();
            }
        }
        if (this.props.hasSlideshow) {
            this.slideshow.play();
        }
    };

    pause = () => {
        window.clearInterval(this.timer);
        if (this.props.isInitialized) {
            window.clearInterval(this.bufferTimer);
            this.refreshBufferState();
            this.bufferTimer = window.setInterval(this.refreshBufferState);
        }
        if (this.props.hasVideo) {
            this.video.pause();
        }
        if (this.props.hasAudio) {
            this.audio.pause();
        }
        if (this.props.hasSlideshow) {
            this.slideshow.pause();
        }
    };

    changeTime = (time) => {
        if (time >= this.props.duration && this.props.duration > 0) {
            this.stop();
            this.props.dispatch({ type: 'NOT_LOADING' });
            this.props.dispatch({ type: 'READING_TERMINATED' });
            this.props.dispatch({ type: 'PAUSE' });
            this.props.dispatch({ type: 'SHOW_MENUS' });
            return;
        }
        if (this.props.isPlaying) {
            window.clearInterval(this.timer);
            this.synchronize();
            this.timer = window.setInterval(this.synchronize, 20);
        }
        window.clearInterval(this.bufferTimer);
        this.refreshBufferState();
        this.bufferTimer = window.setInterval(this.refreshBufferState);
        if (this.props.hasVideo) {
            this.video.changeTime(time);
        }
        if (this.props.hasAudio && time < this.audio.getDuration()) {
            this.audio.changeTime(time);
        }
        if (this.props.hasSlideshow) {
            this.slideshow.changeTime(time);
        }
    };

    stop = () => {
        window.clearInterval(this.timer);
        window.clearInterval(this.bufferTimer);
        if (this.props.hasVideo) {
            this.video.stop();
        }
        if (this.props.hasAudio) {
            this.audio.stop();
        }
        if (this.props.hasSlideshow) {
            this.slideshow.stop();
        }
    };

    setVolume = (volume) => {
        if (this.props.hasVideo)
            this.video.setVolume(volume);
        else if (this.props.hasAudio)
            this.audio.setVolume(volume);
    };

    mute = () => {
        if (this.props.hasVideo)
            this.video.mute();
        else if (this.props.hasAudio)
            this.audio.mute();
    };

    unmute = () => {
        if (this.props.hasVideo)
            this.video.unMute();
        else if (this.props.hasAudio)
            this.audio.unMute();
    };

    hasEnoughBuffered = () => {
        if (this.props.hasVideo)
            return this.props.isVideoReady;
        else if (this.props.hasAudio && this.props.hasSlideshow && this.props.currentTime < this.audio.getDuration())
            return this.props.isAudioReady && this.props.isSlideshowReady;
        else if (this.props.hasAudio && this.props.hasVinyl)
            return this.props.isAudioReady && this.props.isVinylReady;
        else
            return this.props.isSlideshowReady;
    }

    handleChannelsBufferStateChange = () => {
        if (this.hasEnoughBuffered()) {
            this.props.dispatch({ type: 'NOT_LOADING' });
            if (this.props.isPlaying && !this.props.channelsWait) this.play();
        } else {
            this.props.dispatch({ type: 'LOADING' });
            this.pause();
        }
    }

    componentDidMount = () => {
        this.handleChannelsBufferStateChange();
        this.setVolume(this.props.volume);
    }

    shouldComponentUpdate = (nextProps) => {
        //player props changed
        if (this.props.initTime !== nextProps.initTime) {
            window.clearInterval(this.timer);
            window.clearInterval(this.bufferTimer);
        }
        return true;
    }

    UNSAFE_componentWillMount = () => {
        if (this.props.autoplay) {
            window.addEventListener('load', () => {
                this.props.dispatch({ type: 'INITIALIZE_PLAYER' });
                this.props.dispatch({ type: 'PLAY' });
                this.props.dispatch({ type: 'USER_ACTIVE' });
            });
        }
    }

    componentDidUpdate = (prevprops) => {

        if (prevprops.initTime !== this.props.initTime) {
            if (this.props.autoplay){
                this.props.dispatch({ type: 'INITIALIZE_PLAYER' });
                this.props.dispatch({ type: 'PLAY' });
                this.props.dispatch({ type: 'USER_ACTIVE' });
            }
        }

        if (prevprops.isInitialized === false && this.props.isInitialized === true) {
            this.props.dispatch({ type: 'LOADING' });
            if (this.props.hasSlideshow) {
                this.slideshow.load();
            }
            if (this.props.hasAudio && isNaN(this.audio.getDuration())) {
                this.audio.load();
            } else if (this.props.hasVideo && isNaN(this.video.getDuration())) {
                this.video.load();
            } else {
                this.play();
            }
            return;
        }

        if (prevprops.duration !== this.props.duration && this.props.isInitialized) {
            this.play();
        }

        //Prevent other functions based on the audio track duration or the video track duration to generate undesired side-effects
        if (this.props.hasAudio && isNaN(this.audio.getDuration())) {
            return;
        } else if (this.props.hasVideo && isNaN(this.video.getDuration())) {
            return;
        }

        if (prevprops.muted !== this.props.muted) {
            if (this.props.muted) {
                this.mute()
                this.play();
            } else {
                this.unmute()
            }
        }

        if (prevprops.askNextImage !== this.props.askNextImage) {
            let time = this.slideshow.getTimeNextImage();
            this.changeTime(time);
            this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: time } });
        }

        if (prevprops.isAudioReady !== this.props.isAudioReady
            || prevprops.isVideoReady !== this.props.isVideoReady
            || prevprops.isSlideshowReady !== this.props.isSlideshowReady
            || prevprops.isVinylReady !== this.props.isVinylReady
            || prevprops.channelsWait !== this.props.channelsWait) {
            this.handleChannelsBufferStateChange();
        }

        if (prevprops.isPlaying !== this.props.isPlaying) {
            if (!this.props.channelsWait && this.props.isPlaying && this.hasEnoughBuffered() && this.props.duration > 0) this.play();
            else this.pause();
        }

        if (prevprops.channelsWait !== this.props.channelsWait) {
            if (!this.props.channelsWait && this.props.isPlaying && this.hasEnoughBuffered() & this.props.duration > 0) this.play();
            else this.pause();
        }

        if (prevprops.askedTime !== this.props.askedTime && this.props.duration !== 0 && this.props.askedTime !== ASKED_TIME_TREATED) {
            this.changeTime(this.props.askedTime);
            if (this.props.isReadingTerminated && this.props.askedTime < this.props.duration - FLOAT_IMPRECISION) {
                if (isIE() && this.props.hasVideo && this.props.askedTime === 0) {
                    this.video.load();
                    this.video.play();
                }
                this.props.dispatch({ type: 'READING_NOT_TERMINATED' });
                if (this.props.allowUnhighlightProgressBar) {
                    this.props.dispatch({ type: 'PLAY' });
                    this.props.dispatch({ type: 'ALLOW_MENU_HIDING' });
                }
            }
            this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: this.props.askedTime } });
            this.props.dispatch({ type: 'UPDATE_ASKED_TIME', payload: { askedTime: ASKED_TIME_TREATED } });
        }

        if (prevprops.volume !== this.props.volume) {
            this.setVolume(this.props.volume)
        }

        if (prevprops.askPreviousImage !== this.props.askPreviousImage) {
            if (this.props.isReadingTerminated)
                this.props.dispatch({ type: 'READING_NOT_TERMINATED' });
            let time = this.slideshow.getTimePreviousImage();
            this.changeTime(time);
            this.props.dispatch({ type: 'UPDATE_CURRENT_TIME', payload: { currentTime: time } });
        }
    }

    componentWillUnmount = () => {
        window.clearInterval(this.timer);
        window.clearInterval(this.bufferTimer);
    }

    render = () => {
        let video, audio, slideshow, vinyl;
        if (this.props.hasVideo) {
            video = <Video ref={video => (this.video = video)} />;
        }
        if (this.props.hasAudio) {
            audio = <Audio ref={audio => (this.audio = audio)} />;
        }
        if (this.props.hasSlideshow) {
            slideshow = <Slideshow ref={slideshow => (this.slideshow = slideshow)} />
        }
        if (this.props.hasVinyl && this.props.isInitialized) {
            vinyl = <Vinyl />
        }
        return (
            <div style={{ overflow: "hidden" }}>
                {video}
                {audio}
                {slideshow}
                {vinyl}
            </div>
        );
    }
}

const mapStateToProps = (state) => {
    return {
        channelsWait: state.channelsWait,
        timeRangeBuffered: state.timeRangeBuffered,
        askNextImage: state.askNextImage,
        askPreviousImage: state.askPreviousImage,
        volume: state.volume,
        hasVideo: state.hasVideo,
        isVideoReady: state.isVideoReady,
        hasAudio: state.hasAudio,
        isAudioReady: state.isAudioReady,
        hasSlideshow: state.hasSlideshow,
        isSlideshowReady: state.isSlideshowReady,
        isInitialized: state.isInitialized,
        currentTime: state.currentTime,
        askedTime: state.askedTime,
        isPlaying: state.isPlaying,
        duration: state.duration,
        hasVinyl: state.hasVinyl,
        isVinylReady: state.isVinylReady,
        isReadingTerminated: state.isReadingTerminated,
        allowUnhighlightProgressBar: state.allowUnhighlightProgressBar,
        autoplay: state.autoplay,
        muted: state.muted,
        initTime: state.initTime
    };
};

export default connect(mapStateToProps)(Mixer);
